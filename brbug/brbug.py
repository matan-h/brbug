from os import path
import sys
import tarfile
import executing
import inspect
from functools import wraps
from pathlib import Path
# some docstrings generated by chatGPT.

def find_app_path():
    try:
        import toga
        return toga.App.app.paths.app
    except Exception: # no toga
        import traceback
        traceback.print_exc()
        try:
            return Path(sys.argv[0]).absolute().parent
        except Exception:
            import traceback
            traceback.print_exc()
            return "." # assume we are in the correct cwd.


class MySource(executing.Source):
    """
    Custom executing.Source class to use the brBug tar.gz file as a source.
    """
    def __init__(self, filename:str, lines:list):
        """
        Modifies source content by reading from a tar file if valid and available.

        Parameters:
        - filename (str): Name of the file being processed.
        - lines (list): List of lines from the file.
        """
        try:
            tar = tarfile.open(path.join(find_app_path(), "resources", "_brbug.tar.gz"), "r:gz")
            f = tar.extractfile(path.basename(filename))
            content = f.read().decode("utf-8")
            if content:
                lines = content.splitlines(True)
        except (FileNotFoundError, tarfile.TarError, KeyError, UnicodeDecodeError):
            """
            FileNotFoundError: there is no resources/_beedebug.tar.gz
            TarError: resources/_brbug.tar.gz is not a valid tar.gz file
            KeyError: filename is not in the tar file
            UnicodeDecodeError: the filename inside the tar file is not in valid unicode.
            """
            pass

        super().__init__(filename, lines)


executing.Source = MySource

from friendly_traceback.core import FriendlyTraceback  # noqa: E402

def _friendly_string(etype, e, tb)->str:
    """
    Generates a user-friendly string representation of an exception.

    Uses the friendly_traceback module to produce a string representation
    of the exception.
    
    Parameters:
    - etype (type): Type of the exception.
    - e (Exception): The raised exception instance.
    - tb (traceback): Traceback associated with the exception.

    Returns:
    - str: A formatted string containing a simulated Python traceback with additional
      information such as generic error messages, suggestions, and causes if available.
    """
    try:
        fr = FriendlyTraceback(etype, e, tb)
        fr.assign_generic()
        fr.assign_cause()
        simulated_python_traceback = fr.info[
            "simulated_python_traceback"
        ]  # like the normal python traceback, but with the tar data. shortened_traceback is not an option because it only displays the wrapper.
        generic = fr.info.get("generic")  # e.g. A `ZeroDivisionError` occurs when ...
        if generic.startswith("No information is known"):
            generic = ""
        suggest = fr.info.get("suggest", "")
        cause = fr.info.get("cause", "")
        return simulated_python_traceback + "\n" + generic + suggest + cause

    except (
        Exception,
        SystemExit,
    ):  # sometimes executing raise exception about the native code, and Friendly Traceback could just exit(1) at some point
        import traceback

        traceback.print_exc()
        return "".join(traceback.format_exception(etype, e, tb))


def friendly_string(e:Exception):
    """
    Generates a user-friendly string representation of an exception.

    Uses `_friendly_string` to process the exception instance `e`
    and its associated traceback.

    Parameters:
    - e (Exception): The raised exception instance.

    Returns:
    - str: A user-friendly string representation of the traceback.
    """
    return _friendly_string(type(e), e, e.__traceback__)


def popup_error(e):
    """
    Displays an error popup window.

    Displays the error message `e` in a popup window using a GUI library.

    Parameters:
    - e (str): Error message to display in the popup window.
    """
    import toga
    main_window = toga.App.app.main_window
    main_window.error_dialog("BrBug", str(e))


def catch(fn):
    """
    Decorator that catches exceptions raised within a function.

    Wraps the function `fn` to catch any raised exceptions, print a
    user-friendly traceback to stderr, and display it in a popup window.

    Parameters:
    - fn (function): Function to be decorated.

    Returns:
    - function: Decorated function.
    """

    @wraps(fn)
    def wrapper(*args, **kwargs):
        try:
            return fn(*args, **kwargs)
        except Exception as e:  # print the traceback, then popup it. if the popup is no longer working, crash.
            traceback = friendly_string(e)
            print(traceback, file=sys.stderr)
            try:
                popup_error(traceback)
            except Exception:
                raise e # if we have no toga, the error would be printed twice: 1. the friendly traceback, 2. here with the raise
    return wrapper


def catch_beeapp(cls):
    """
    Decorator that catches exceptions for user-defined methods within a class.

    Modifies user-defined methods within the class `cls` (excluding magic methods
    and inherited methods) to catch any raised exceptions, print a user-friendly
    traceback to stderr, and display it in a popup window.

    Parameters:
    - cls (class): Class containing user-defined methods to be decorated.

    Returns:
    - class: Decorated class.
    """
    methods = inspect.getmembers(cls, predicate=inspect.isfunction)  # get all functions
    for method_name, method_func in methods:
        if (
            inspect.isfunction(method_func) # ensure they are a function
            and method_func.__qualname__.startswith(cls.__qualname__) # filter to keep only the inherited
            and not method_name.startswith("__") # and not the magic functions (they can still be @catch ed)
        ):
            setattr(cls, method_name, catch(method_func))

    return cls
